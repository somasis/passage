#!/bin/sh

set -ef

## Default variables

: "${XDG_CONFIG_HOME:=${HOME}/.config}"
: "${XDG_DATA_HOME:=${HOME}/.local/share}"

# This may or may not be used, so don't try and check the source.
# shellcheck disable=SC1090
[ -f "${XDG_CONFIG_HOME}"/passage/passage.conf ] && . "${XDG_CONFIG_HOME}"/passage/passage.conf

: "${PASSAGE_DIR:=${XDG_DATA_HOME}/passage}"
: "${PASSAGE_KEY:=${XDG_CONFIG_HOME}/passage/privkey}"
: "${PASSAGE_RECIPIENTS:=${XDG_CONFIG_HOME}/passage/recipients}"
: "${PASSWORD_STORE_DIR:=${HOME}/.password-store}"

# Only use a directory for temporary files that is guaranteed to be on memory.
export TMPDIR=/dev/shm

PASSAGE_DIR=$(readlink -f "${PASSAGE_DIR}")

export PASSAGE_DIR PASSAGE_KEY PASSAGE_RECIPIENTS

## Functions

decrypt() {
    age -d -i "${PASSAGE_KEY}" "$@"
}

encrypt() {
    file="$1"

    set --
    while read -r recipient; do
        set -- -r "${recipient}"
    done < "${PASSAGE_RECIPIENTS}"

    age "$@" -a "${file}"
}

is_beneath_store() {
    while [ "$#" -gt 0 ]; do
        case "$(readlink -f "${1}")" in
            "${PASSAGE_DIR}"/*|"${PASSAGE_DIR}") : ;;
            *)
                printf 'error: file path "%s" is not within the password store\n' "${1}" >&2
                exit 4
                ;;
        esac
        shift
    done
}

usage() {
    cat >&2 <<EOF
usage: passage convert [-v] [DIRECTORY...]
       passage cp [-fr] SOURCE DESTINATION
       passage edit FILE...
       passage generate [-f] [-l LENGTH] FILE
       passage init
       passage ln [-f] TARGET DESTINATION
       passage mkdir [-p] DIRECTORY...
       passage mv [-f] SOURCE DESTINATION
       passage rm [-fr] FILE/DIRECTORY...
       passage show [-c] [FILE/DIRECTORY...]
EOF

    exit 127
}

pretty_list() {
    [ "$#" -eq 0 ] && set -- .
    while [ $# -gt 0 ]; do
        find "${1}" -type d \( -not -name '.*' \) | sed -E 's|$|/|; s|/+$|/|'
        find "${1}" \( -type f -name '*.age' \)
        shift
    done | sed 's|\.age$||; s|^\./||' | sort -d
}

## Modes

passage_convert() {
    gpg_args="-q"
    verbose=false
    while getopts :v arg >/dev/null 2>&1; do
        case "${arg}" in
            v)
                verbose=true
                ;;
            ?)
                printf 'unknown argument -- %s\n' "${1}" >&2
                usage
                ;;
        esac
    done

    shift $(( OPTIND - 1 ))

    if "${verbose}"; then
        gpg_args=
    fi

    [ "$#" -eq 0 ] && set -- "${PASSWORD_STORE_DIR}"

    # Temporary enable path globbing.
    set +f
    while [ $# -gt 0 ]; do
        cp -r "$1"/* "${PASSAGE_DIR}"
        shift
    done
    set -f

    # Convert all gpg-encrypted files to age-encrypted files.
    find . -name '*.gpg' -type f -not -type l | while read -r file; do
        "${verbose}" && printf '%s\n' "${file}" >&2
        gpg "${gpg_args}" --batch -d "${file}" | encrypt > "${file%.gpg}.age"
        rm -f "${file}"
    done

    # Fix symbolic links that point to .gpg files.
    find . -name '*.gpg' -type l | while read -r name; do
        new_link=$(readlink "${name}")
        new_link="${new_link%.gpg}".age
        new_name="${name%.gpg}".age
        ln -sf "${new_link}" "${new_name}"
        rm -f "${name}"
    done
}

passage_edit() {
    while [ $# -gt 0 ]; do
        is_beneath_store "$1"

        if [ -f "${1}".age ]; then
            temp=$(mktemp "${TMPDIR}"/passage.XXXXXX)
            chmod 700 "${temp}"

            decrypt "${1}".age > "${temp}"

            "${EDITOR:-vi}" "${temp}" || {
                printf \
                    'error: editor died with error code %s, cleaning up decrypted file\n' "$?" >&2
                rm -f "${temp}"
            }

            encrypt "${temp}" > "${1}".age
            rm -f "${temp}"
        else
            "${EDITOR:-vi}" "${1}" || {
                printf 'error: editor died with error code %s\n' "$?" >&2
            }
            encrypt "${1}" > "${1}".age
        fi

        shift
    done

}

passage_generate() {
    clobber=false
    length=24
    while getopts :fl arg >/dev/null 2>&1; do
        case "${arg}" in
            f)
                clobber=true
                ;;
            l)
                length="${OPTARG}"
                ;;
            ?)
                printf 'unknown argument -- %s\n' "${OPTARG}" >&2
                usage
                ;;
        esac
    done

    shift $(( OPTIND - 1 ))

    case "${length}" in
        *[!0-9]*)
            printf 'error: length "%s" is not an integer\n' "${length}" >&2
            exit 127
            ;;
    esac

    while [ $# -gt 0 ]; do
        is_beneath_store "$1"

        if [ -e "${1}" ] && ! "${clobber}"; then
            printf \
                'error: password file "%s" already exists, refusing to clobber without -f\n' \
                "${1}" >&2
            exit 2
        fi

        mkdir -p "${1%/*}"

        # NOTE: Using bs="${length}" count=1 rather than bs=1 count="${length}" saves syscalls.
        LC_ALL=C tr -cd '[:alnum:][:punct:]' </dev/urandom \
            | dd bs="${length}" count=1 2>/dev/null | encrypt > "${1}".age

        shift
    done
}

passage_init() {
    mkdir -p "${PASSAGE_DIR}"
    mkdir -p "$(dirname "${PASSAGE_KEY}")" "$(dirname "${PASSAGE_RECIPIENTS}")"
    [ -f "${PASSAGE_KEY}" ] || age-keygen -o "${PASSAGE_KEY}"
    [ -f "${PASSAGE_RECIPIENTS}" ] \
        || sed '/^#.* age1.*/ !d; s/.*age1/age1/' "${PASSAGE_KEY}" > "${PASSAGE_RECIPIENTS}"i
}

passage_show() {
    copy=false
    while getopts :c arg >/dev/null 2>&1; do
        case "${arg}" in
            c)
                copy=true
                ;;
            ?)
                printf 'unknown argument -- %s\n' "${OPTARG}" >&2
                usage
                ;;
        esac
    done

    shift $(( OPTIND - 1 ))

    if [ -d "${1}" ] || [ -z "${1}" ]; then
        pretty_list "$@"
        return $?
    fi

    is_beneath_store "$1".age

    if [ -f "${1}".age ]; then
        if "${copy}"; then
            decrypt "${1}".age | xsel -ib
            printf 'Password copied to clipboard. Clipboard will be cleared in 45 seconds.\n' >&2
            (
                sleep 45
                xsel -cb
            ) &
        else
            decrypt "${1}".age
        fi
    else
        printf 'error: password file "%s" does not exist\n' "${1}" >&2
        exit 3
    fi
}

## File operation commands

passage_cp() {
    force=
    recurse=
    while getopts :fr arg >/dev/null 2>&1; do
        case "${arg}" in
            f)
                force=true
                ;;
            r)
                recurse=true
                ;;
            ?)
                printf 'unknown argument -- %s\n' "${OPTARG}" >&2
                usage
                ;;
        esac
    done

    shift $(( OPTIND - 1 ))

    [ "$#" -eq 2 ] || {
        printf 'error: missing destination file\n' >&2
        usage
    }

    is_beneath_store "$1"

    if [ -d "${1}" ]; then
        cp ${force:+-f} ${recurse:+-r} "$1" "$2"
    else
        cp ${force:+-f} ${recurse:+-r} "$1".age "$2".age
    fi
}

passage_ln() {
    force=
    while getopts :f arg >/dev/null 2>&1; do
        case "${arg}" in
            f)
                force=true
                ;;
            ?)
                printf 'unknown argument -- %s\n' "${OPTARG}" >&2
                usage
                ;;
        esac
    done

    shift $(( OPTIND - 1 ))

    is_beneath_store "$@"

    if [ -d "${1}" ]; then
        ln -s ${force:+-f} "$1" "$2"
    else
        ln -s ${force:+-f} "$1".age "$2".age
    fi
    shift
}

passage_mkdir() {
    parents=
    while getopts :p arg >/dev/null 2>&1; do
        case "${arg}" in
            p)
                parents=true
                ;;
            ?)
                printf 'unknown argument -- %s\n' "${OPTARG}" >&2
                usage
                ;;
        esac
    done

    shift $(( OPTIND - 1 ))

    is_beneath_store "$@"

    mkdir ${parents:+-p} "$@"
}

passage_mv() {
    force=
    while getopts :f arg >/dev/null 2>&1; do
        case "${arg}" in
            f)
                force=true
                ;;
            ?)
                printf 'unknown argument -- %s\n' "${OPTARG}" >&2
                usage
                ;;
        esac
    done

    shift $(( OPTIND - 1 ))

    is_beneath_store "$@"

    if [ -d "${1}" ]; then
        mv ${force:+-f} "$1" "$2"
    else
        mv ${force:+-f} "$1".age "$2".age
    fi
}

passage_rm() {
    recurse=
    force=
    while getopts :fr arg >/dev/null 2>&1; do
        case "${arg}" in
            f)
                force=true
                ;;
            r)
                recurse=true
                ;;
            ?)
                printf 'unknown argument -- %s\n' "${OPTARG}" >&2
                usage
                ;;
        esac
    done

    shift $(( OPTIND - 1 ))

    while [ "$#" -gt 0 ]; do
        is_beneath_store "$1"

        if [ -d "${1}" ]; then
            rm ${force:+-f} ${recurse:+-r} "$1"
        else
            rm ${force:+-f} ${recurse:+-r} "$1".age
        fi

        shift
    done
}

shift $(( OPTIND - 1 ))

mode=
case "${1:-help}" in
    convert|cp|edit|generate|init|ln|mkdir|mv|rm|show)
        mode="${1}"
        ;;
    help) usage ;;
    *)
        printf 'unknown argument -- %s\n' "${1}" >&2
        usage
        ;;
esac

shift

case "${mode}" in
    help|init) : ;;
    *)
        [ -s "${PASSAGE_KEY}" ] || {
            printf 'error: key file "%s" either does not exist or is empty\n' "${PASSAGE_KEY}" >&2
            exit 4
        }
        [ -s "${PASSAGE_RECIPIENTS}" ] || {
            printf 'error: recipient file "%s" either does not exist or is empty\n' "${PASSAGE_RECIPIENTS}" >&2
            exit 4
        }

        cd "${PASSAGE_DIR}"

        ;;
esac

passage_"${mode}" "$@"
